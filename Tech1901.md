# 2月

## 0209

### [C++11中的技术剖析(萃取技术)](https://www.cnblogs.com/mod109/p/9236401.html)
我在实际使用的时候，貌似不需要准备类型判别，以及左右值的判断。但是作者关于源码的解析，并且使用反汇编的方式呈现出来让人吃惊。

+ macro
+ miscellaneous
+ vendor

## 0210

### [String类实现细节](C++编程思想_第二卷_C3.1_P59)
相同字符串，被修改时才创建拷贝，写时复制(copy-on-write)。

## 0213

### [stl中的for_each性能测试及为何性能如此之高](https://bbs.csdn.net/topics/380148763)   [STL中vector以及 for_each几种用法](https://blog.csdn.net/u011641885/article/details/44539955)
vector迭代器失效：  当我们插入一个元素时它的预分配空间不够时，它会重新申请一段新空间，将原空间上的元素复制到新的空间上去，然后再把新加入的元素放到新空间的尾部，以满足vector元素要求连续存储的目的。  正确的做法是  超过vector容量后，重新取一次迭代器。

### [c++11 lambda函数是不是内联的](https://zhidao.baidu.com/question/1370704972325632139.html)
“一个lambda表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的内联函数。” C++primer（中文第五版P389）

### [SIMT和SIMD](https://blog.csdn.net/kebu12345678/article/details/79069188)  [C++中使用SIMD的几种方法](https://blog.csdn.net/a812073479/article/details/80549436)
GPU中的SIMT体系结构相对于CPU的SIMD中的概念。为了有效地管理和执行多个单线程，多处理器采用了SIMT架构。此架构在第一个unified computing GPU中由NVIDIA公司生产的GPU引入。

+ SIMT与SIMD本质相同，都是单指令多数据。
+ SIMT比SIMD更灵活，允许一条指令的多数据分开寻址；SIMD是必须连续在一起的片段。
+ SIMT形式上是多线程，本质上还是一个线程，只不过数据可以零散的分散开。但是如果你真的将数
+ 据分散开的话，执行效率上又会大打折扣，因为不满足并行访问的要求。
`总之SIMT是SIMD的一种推广，更灵活而已。`
